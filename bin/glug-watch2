#!/usr/bin/env coffee

base_path = process.cwd()

require('app-module-path').addPath("#{base_path}/node_modules")

async_require = ->
  if arguments[0] and arguments[1]
    name = arguments[1]
    alias = arguments[0]
  else
    name = arguments[0]
    alias = arguments[0]

  new Promise (resolve, reject) =>
    global[alias] = require(name)
    resolve()
  
require_dependencies = =>
  Promise.all [
    async_require('program', 'commander')
    async_require('h', './helpers')
    async_require('fs', 'graceful-fs')
    async_require('path')
    async_require('mkdirp')
    async_require('chokidar')
    async_require('jstransformer')
    async_require('recursive', 'fs-readdir-recursive')
    async_require('anymatch')
    async_require('matter', 'gray-matter')
    async_require('browser-sync')
    async_require('tfunk')
  ]

config_path = "#{base_path}/glug-config.coffee"

try
  config = require(config_path)
catch error
  throw 'error' + error + "\nconfig file not found at #{config_path}.coffee"

setup_commands = ->
  new Promise (resolve, reject) =>
    program
      .option('-v, --verbose', 'print more output')
      .parse(process.argv)
    h.debug 'Setting up application commands and options'
    resolve()

transformer_names = config.transformers
transformers = {}

load_transformer = (name) ->
  new Promise (resolve, reject) =>
    h.debug "Requiring JSTransformer: #{name}"
    try
      transformers[name] = jstransformer(require("jstransformer-#{name}"))
      resolve()
    catch error
      reject h.log 'error',
        """
        #{error}
    
        Try running `npm install --save jstransformer-#{name}`
        or `yarn add jstransformer-#{name}`
        """.replace('Error: ', '')

load_all_transformers = ->
  promises = []
  for name, options of transformer_names
    promises.push load_transformer(name)
  Promise.all(promises)
    .then -> h.debug 'Finished requiring JSTransformers'

paths = {}

input_dir  = config.input_dir  || 'app'
output_dir = config.output_dir || 'public'

files = {}
pipelines = {}

generate_file_list = ->
  new Promise (resolve, reject) ->
    h.debug 'Making file list...'
    all_files = recursive(input_dir)
    for file in all_files
      for pipeline_name, pipeline of config.pipelines
        for tier_name, tier of pipeline
          for glob, transforms of tier
            # Convert transforms to array if necessary

            if typeof transforms is 'string'
              transforms = [transforms]

            if anymatch(glob, file)
              pipelines[pipeline_name] ||= {}
              pipelines[pipeline_name][tier_name] ||= {}
              pipelines[pipeline_name][tier_name][file] ||= {}
              file_ref = pipelines[pipeline_name][tier_name][file]
              file_ref.transforms ||= []
              file_ref.transforms = file_ref.transforms.concat transforms
      files[file] = {}
      files[file].is_rendered = false

    h.debug h.json files
    h.debug h.json pipelines
    h.debug 'File list is finished'
    resolve()

prepare_output_dir = ->
  new Promise (resolve, reject) ->
    try
      h.rm_dir output_dir
      unless fs.existsSync(output_dir)
        fs.mkdir(output_dir)
      resolve()
    catch err
      reject err

start_watcher = ->
  new Promise (resolve, reject) ->
    chokidar.watch(input_dir, {}).on 'all', (event, file) ->
      if event is 'change' or event is 'remove' or event is 'add'
        file = file.replace input_dir + '/', ''
        h.debug "#{file} #{event}d"
        files[file].is_rendered = false
        render_all()
        #   .then (files_changed) =>
        #     bs.reload(files_changed)
        #   .catch (err) =>
        #     reject err

render_file_tier = (file, tier) ->
  new Promise (resolve, reject) =>
    h.debug "file: #{file}"
    # h.debug "file: #{file}, data: #{h.json tier.data[file]}"
    resolve("hiya from render_file_tier with #{file}")

render_all_in_tier = (pipeline, tier) ->
  file_promises = []
  for file of tier.data
    unless file.is_rendered
      console.log "tier is #{tier.name}"
      promise = render_file_tier(file, tier)
      promise.then =>
        if pipeline[tier.name] is h.last(pipeline).name
          h.debug "Got through last tier"
          files[file].is_rendered = true
        else
          h.debug "more tiers to go"
          render_all_in_tier(pipeline, h.next(pipeline, tier.name))
      file_promises.push promise
  Promise.all(file_promises)
    # .then =>
    #   render_all_in_tier

render_all = ->
  pipeline_promises = []
  for pipeline_name, pipeline of pipelines
    h.debug h.bold "#{pipeline_name} Pipeline"
    render_all_in_tier(pipeline, h.first(pipeline))
  Promise.all(pipeline_promises)

require_dependencies()
  .then -> setup_commands()
  .then -> load_all_transformers()
  .then -> generate_file_list()
  .then -> prepare_output_dir()
  .then -> start_watcher()
  .catch (err) -> throw err

# make_file_data_for = (file) ->
#   for pipeline_name, pipeline of config.pipelines
#     files[pipeline_name] = {}
#     for tier_name, tier of pipeline
#       for glob, glob_transformers of tier
#         if typeof glob_transformers is 'string'
#           glob_transformers = [glob_transformers]
#         if anymatch(glob, file)
#           files[pipeline_name][file] = {}
#           file_ref = files[pipeline_name][file]
#           file_ref.transformers = {}
#           file_ref.transformers[tier_name] ||= []
#           file_ref.transformers[tier_name] =
#             file_ref.transformers[tier_name].concat(glob_transformers)

#   input_format = path.extname(file).replace('.', '')

#   transformer_order = files[file].transformers
#   if transformer_order = {}
#     transformer_order =
#       first: [ 'copy' ]
#     file_ref.transformers = transformer_order
#     new_name = file

#   else
#     tier_names = Object.keys(transformer_order)
#     last_tier = transformer_order[tier_names[tier_names.length - 1]]
#     last_renderer = last_tier[last_tier.length - 1]
#     output_format = renderers[last_renderer].outputFormat
#     new_name = file.replace(input_format, output_format).replace(output_dir, '')

#   files[file] = merge files[file],
#     is_rendered: false
#     new_path: path.join(output_dir, new_name)
#     input_format: input_format
#     output_format: output_format

# bs_options = merge({
#   server: output_dir
# }, config.server)

# bs.init(bs_options)

# render = (filename, contents, renderer_names, settings={}) ->
#   new Promise (resolve, reject) =>
#     file_data = matter(contents)

#     contents = file_data.content
#     frontmatter = file_data.data

#     if renderer_names is 'copy'
#       resolve(contents)

#     default_transformers_config =
#       stylus:
#         paths: [
#           input_dir
#         ]

#     renderer_name = renderer_names[0]

#     debug "#{filename}: rendering with #{renderer_name}"
#     renderer = renderers[renderer_name]
#     renderer_config = transformers[renderer_name]

#     output_format = renderer.outputFormat

#     renderer_config = merge(settings, renderer_config, frontmatter)

#     renderer.renderAsync(contents, renderer_config)
#       .then (rendered_contents) =>
#         debug "#{filename}: finished rendering with #{renderer_name}"
#         rendered_contents = rendered_contents.body
#         renderers_left = renderer_names[1..]
#         if renderers_left.length is 0 or renderers_left is undefined
#           resolve(rendered_contents)
#         else
#           render(filename, rendered_contents, renderers_left)
#             .then (final_contents) =>
#               resolve(final_contents)
#             .catch (err) =>
#               reject log 'error', renderer_names[0], '\n' + err
#               # throw log 'error', renderer_names[0], '\n' + err
#       .catch (err) =>
#         reject log 'error', '\n' + err

# render_tier = (file, text) ->
#   console.log "render_tier('#{file}')"

#   new Promise (resolve, reject) =>

#     file_data = files[file]

#     tier = 'syntax'

#     "render('#{file}', '#{text}', '#{file_data.transformers[tier]}', opts)"
#     render(file, text, file_data.transformers[tier],
#       filename: path.join(input_dir, file), basedir: output_dir)
#       .then (rendered_contents) =>
#         write_file(file_data.new_path, rendered_contents)
#         resolve()
#       .catch (err) ->
#         reject err

# render_file_tier = (file) ->
#   console.log "render_file_tier('#{file}')"

#   new Promise (resolve, reject) =>

#     file_data = files[file]

#     if file_data.is_rendered
#       resolve(file_data.new_path)

#     console.log JSON.stringify file_data.transformers, null, 2
#     # list_of_renderers = file_data.transformers.join(' => ')
#     # debug ".#{file_data.input_format}
#     #   => #{list_of_renderers}
#     #   => .#{file_data.output_format}"

#     fs.readFile path.join(input_dir, file), { encoding: 'utf8' }, (err, text) =>

#       if err
#         reject err

#       render_tier(file, text)
#         .then =>
#           file_data.is_rendered = true
#           resolve()
#         .catch (err) =>
#           reject err

# render_all = ->
#   new Promise (resolve, reject) ->
#     # pipeline_promises = []
#     # for pipeline of files
#     #   file_promises = []
#     #   for file of files
#     #     file_promises.push render_file_tier(file)
#     #   Promise.all(promises)
#     #     .then =>
#     #       resolve('hi')
#     #     .catch (err) =>
#     #       reject err

# make_file_list()
#   .catch (err) ->
#     throw err
#   .then ->
#     console.log JSON.stringify files, null, 2

#     render_all().then ->
#       chokidar.watch(input_dir, {}).on 'all', (event, file) ->
#         if event is 'change' or event is 'remove' or event is 'add'
#           file = file.replace input_dir + '/', ''
#           files[file].is_rendered = false
#           render_all()
#             .then (files_changed) =>
#               bs.reload(files_changed)
#             .catch (err) =>
#               throw err

# debug 'script ended'
# chokidar.watch(input_dir, {}).on 'all', (event, file) ->
#   if event is 'change' or event is 'remove' or event is 'add'
#     console.log 'hi'
