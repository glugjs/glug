#!/usr/bin/env coffee

base_path = process.cwd()

require('app-module-path').addPath("#{base_path}/node_modules")
Promise = require('bluebird')
console.log Promise

async_require = ->
  if arguments[0] and arguments[1]
    name = arguments[1]
    alias = arguments[0]
  else
    name = arguments[0]
    alias = arguments[0]

  new Promise (resolve, reject) =>
    global[alias] = require(name)
    resolve()
  
require_dependencies = =>
  Promise.all [
    async_require('program', 'commander')
    async_require('h', './helpers')
    async_require('fs', 'graceful-fs')
    async_require('path')
    async_require('mkdirp')
    async_require('chokidar')
    async_require('jstransformer')
    async_require('recursive', 'fs-readdir-recursive')
    async_require('anymatch')
    async_require('matter', 'gray-matter')
    async_require('browser-sync')
    async_require('tfunk')
  ]

config_path = "#{base_path}/glug-config.coffee"

try
  config = require(config_path)
catch error
  throw 'error' + error + "\nconfig file not found at #{config_path}.coffee"

setup_commands = ->
  new Promise (resolve, reject) =>
    program
      .option('-v, --verbose', 'print more output')
      .parse(process.argv)
    h.debug 'Setting up application commands and options'
    resolve()

transformer_names = config.transformers
transformers = {}

load_transformer = (name) ->
  new Promise (resolve, reject) =>
    h.debug "Requiring JSTransformer: #{name}"
    try
      transformers[name] = jstransformer(require("jstransformer-#{name}"))
      resolve()
    catch error
      reject h.log 'error',
        """
        #{error}
    
        Try running `npm install --save jstransformer-#{name}`
        or `yarn add jstransformer-#{name}`
        """.replace('Error: ', '')

load_all_transformers = ->
  promises = []
  for name, options of transformer_names
    promises.push load_transformer(name)
  Promise.all(promises)
    .then -> h.debug 'Finished requiring JSTransformers'

paths = {}

input_dir  = config.input_dir  || 'app'
output_dir = config.output_dir || 'public'

files = {}
pipelines = {}

generate_file_list = ->
  new Promise (resolve, reject) ->
    h.debug 'Making file list...'
    all_files = recursive(input_dir)
    for file in all_files
      files[file] = {}
      files[file].is_rendered = false
      files[file].in_format = path.extname(file).replace('.', '')
      for pipeline_name, pipeline of config.pipelines
        for tier_name, tier of pipeline
          for glob, transforms of tier
            # Convert transforms to array if necessary

            if typeof transforms is 'string'
              transforms = [transforms]

            if anymatch(glob, file)
              last_transformer = h.last(transforms).data
              files[file].out_format = transformers[last_transformer].outputFormat
              pipelines[pipeline_name] ||= {}
              pipelines[pipeline_name][tier_name] ||= {}
              pipelines[pipeline_name][tier_name][file] ||= {}
              file_ref = pipelines[pipeline_name][tier_name][file]
              file_ref.transforms ||= []
              file_ref.transforms = file_ref.transforms.concat transforms

      files[file].out_format ||= files[file].in_format
      files[file].out_path = file.replace(
        files[file].in_format,
        files[file].out_format
      )

    h.debug "Files: #{h.json files}"
    h.debug "Pipelines: #{h.json pipelines}"
    h.debug 'File list is finished'
    resolve()

prepare_output_dir = ->
  new Promise (resolve, reject) ->
    try
      h.rm_dir output_dir
      unless fs.existsSync(output_dir)
        fs.mkdir(output_dir)
      resolve()
    catch err
      reject err

start_watcher = ->
  new Promise (resolve, reject) ->
    chokidar.watch(input_dir, {}).on 'all', (event, file) ->
      if event is 'change' or event is 'remove' or event is 'add'
        file = file.replace input_dir + '/', ''
        h.debug "#{file} #{event}d"
        files[file].is_rendered = false
        render_all()
        #   .then (files_changed) =>
        #     bs.reload(files_changed)
        #   .catch (err) =>
        #     reject err

render = (filename, contents, renderer_names, settings={}) ->
  new Promise (resolve, reject) =>
    bad_things = ["", undefined, null]

    if bad_things.includes contents
      h.warn("I want to render #{filename} with #{renderer_names[0]}, but I can't because #{filename} is #{contents}")
      return resolve("")

    if typeof contents isnt 'string'
      h.warn("The contents of #{filename} is of type #{typeof contents}, and is:
        #{h.json contents}")

    file_data = matter(contents)

    contents = file_data.content
    frontmatter = file_data.data

    if renderer_names is 'copy'
      return resolve(contents)

    default_transformers_config =
      stylus:
        paths: [
          input_dir
        ]

    renderer_name = renderer_names[0]

    renderer = transformers[renderer_name]

    output_format = renderer.outputFormat

    renderer_config = h.merge(settings, frontmatter)

    h.debug "#{filename}: {red:#{renderer_name}}"

    renderer.renderAsync(contents, renderer_config)
      .then (rendered_contents) =>
        h.debug "#{filename}: finished rendering with #{renderer_name}"
        rendered_contents = rendered_contents.body
        renderers_left = renderer_names[1..]
        if renderers_left.length is 0 or renderers_left is undefined
          resolve(rendered_contents)
        else
          render(filename, rendered_contents, renderers_left)
            .then (final_contents) =>
              resolve(final_contents)
            .catch (err) => reject "Error from sub-render: #{err}"
      .catch (err) => reject "Error from render: #{renderer_name}: #{err}"

render_file_tier = (file, tier, first = true) ->
  new Promise (resolve, reject) =>
    h.debug "render_file_tier('#{file}', '#{tier.name}')"
    return reject("Fake error in render_file_tier")

    file_data = files[file]

    # if file_data.is_rendered
    #   return resolve()

    # console.log JSON.stringify file_data.transformers, null, 2

    h.debug "First: #{first}"
    if first
      file_path = path.join(input_dir, file)
    else
      file_path = path.join(output_dir, files[file].out_path)

    h.debug "Looking for file at #{file_path}"
    fs.readFile file_path, { encoding: 'utf8' }, (err, text) =>
      h.debug "Found file at #{file_path}"

      if err
        return reject err

      render(file, text, tier.data[file].transforms,
        filename: file_path, basedir: output_dir)
        .then (rendered_contents) =>
          # h.debug "rendered_contents are #{rendered_contents}"
          h.write_file(path.join(output_dir, file_data.out_path), rendered_contents)
            .then resolve

        .catch reject

render_all_in_tier = (pipeline, tier, first = true) ->
  new Promise (reject, resolve) =>
    file_promises = []
    for file of tier.data
      unless file.is_rendered
        promise = render_file_tier(file, tier, first)
        file_promises.push promise
        promise.catch (err) ->
          h.info "got err in render_all_in_tier: #{err}"
          return reject err
    Promise.all(file_promises)
      .catch (err) ->
        # h.debug "got error in render_all_in_tier"
        reject err
      # .catch reject
      .then =>
        h.debug "Finished tier: #{tier.name}"
        next_tier = h.next(pipeline.data, tier.name)
        if next_tier?
          h.debug "more tiers to go for #{pipeline.name}"
          render_all_in_tier(pipeline, next_tier, first = false)
            .catch (err) ->
              h.info "err in sub render_all_in_tier: #{err}"
              return reject err
            .then resolve
        else
          h.debug "Got through last tier for #{pipeline.name}"
          files[file].is_rendered = true
          resolve()

render_all = ->
  new Promise (resolve, reject) ->
    pipeline_promises = []
    for pipeline_name, pipeline of pipelines
      h.debug h.bold "#{pipeline_name} Pipeline"
      render_all_in_tier(
        { name: pipeline_name, data: pipeline },
        h.first(pipeline))
          .catch (err) ->
            h.info "got error in render_all"
            reject err
    Promise.all(pipeline_promises)

require_dependencies()
  .then setup_commands
  .then load_all_transformers
  .then generate_file_list
  .then prepare_output_dir
  .then render_all
  # .then start_watcher
  .catch (err) -> throw err
