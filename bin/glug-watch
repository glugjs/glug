#!/usr/bin/env coffee

base_path = process.cwd()

require('app-module-path').addPath("#{base_path}/node_modules")
program = require('commander')
fs = require('graceful-fs')
path = require('path')
mkdirp = require('mkdirp')
chokidar = require('chokidar')
transformer = require('jstransformer')
recursive = require('fs-readdir-recursive')
anymatch = require('anymatch')
matter = require('gray-matter')
b_sync = require('browser-sync')
hljs = undefined

tfunk = require('tfunk')

log = () ->

  args = Array::slice.call(arguments)

  log_types = ['log', 'warn', 'error', 'debug']

  if args[0] and args[1] and args[2]
    type = args[0]
    sender = args[1]
    strings = args[2..]

  else if args[0] and args[1]
    strings = args[1..]

    if log_types.includes args[0]
      type = args[0]

    else
      sender = args[0]

  else
    strings = args[0..]

  type ||= 'log'
  sender ||= 'glug'

  string = strings.join(' ')

  switch sender
    when 'glug'
      color = 'green'
    else
      color = 'yellow'

  prefix = "[{#{color}:#{sender}}]"

  switch type
    when 'log'
      color = 'gray'
    when 'warn'
      color = 'yellow'
    when 'error'
      color = 'red'
    when 'debug'
      color = 'blue'
    else
      color = 'gray'

  prefix += "[{#{color}:#{type}}] "

  return tfunk(prefix + string)

program
  .option('-v, --verbose', 'print more output')
  .parse(process.argv)

print = console.log

info = () ->

debug = () ->
  if program.verbose?
    print log 'debug', arguments...

config_path = "#{base_path}/glug-config.coffee"

try
  config = require(config_path)
catch error
  throw log 'error', "config file not found at #{config_path}.coffee"
  
bs = b_sync.create()

merge = ->
  new_object = {}
  for object in arguments
    for key of object
      new_object[key] = object[key]
  new_object

write_file = (file, contents) ->
  debug "about to write #{file}"

  mkdirp path.dirname(file)
  fs.writeFile file, contents, (err) ->
    if err
      throw err

rm_dir = (path) ->
  if fs.existsSync(path)
    fs.readdirSync(path).forEach (file, index) ->
      curPath = path + '/' + file
      if fs.lstatSync(curPath).isDirectory()
        # recurse
        rm_dir curPath
      else
        # delete file
        fs.unlinkSync curPath
      return
    fs.rmdirSync path

transformers = {}

transformers = merge(transformers, config.transformers)

renderers = {}

debug 'about to require jstransformers'
for name, options of transformers
  debug "Requiring JSTransformer: #{name}"
  try
    renderers[name] = transformer(require("jstransformer-#{name}"))
  catch error
    throw log 'error',
      """
      #{error}
  
      Try running `npm install --save jstransformer-#{name}`
      or `yarn add jstransformer-#{name}`
      """.replace('Error: ', '')

debug 'done requiring jstransformers'

paths = {}

input_dir  = config.input_dir  || 'app'
output_dir = config.output_dir || 'public'

if transformers['markdown-it']? and transformers['markdown-it'].highlight?
  hljs = require('highlight.js')
  transformers['markdown-it'].highlight = (str, lang) ->
    if lang and hljs.getLanguage(lang)
      try
        return hljs.highlight(lang, str).value
      catch __
    ''

transformers_for = (filetype) ->
  renderer_names = []
  if config.files? and config.files[filetype]?
    return config['files'][filetype]
  else
    for name, transformer of transformers
      renderer = renderers[name]
      if renderer.inputFormats.includes(filetype)
        renderer_names.push name

    if renderer_names.length is 0
      debug 'renderer_names is empty'
      return []

    last_renderer_name = renderer_names[renderer_names.length - 1]
    last_extension = renderers[last_renderer_name].outputFormat
    if last_extension isnt filetype
      for new_renderer in transformers_for(last_extension)
        renderer_names.push new_renderer

  return renderer_names

all_files = recursive(input_dir)

files = {}

make_file_data_for = (file) ->
  for pipeline_name, pipeline of config.pipelines
    files[pipeline_name] = {}
    for tier_name, tier of pipeline
      for glob, glob_transformers of tier
        if typeof glob_transformers is 'string'
          glob_transformers = [glob_transformers]
        if anymatch(glob, file)
          files[pipeline_name][file] = {}
          file_ref = files[pipeline_name][file]
          file_ref.transformers = {}
          file_ref.transformers[tier_name] ||= []
          file_ref.transformers[tier_name] =
            file_ref.transformers[tier_name].concat(glob_transformers)

  input_format = path.extname(file).replace('.', '')

  transformer_order = files[file].transformers
  if transformer_order = {}
    transformer_order =
      first: [ 'copy' ]
    file_ref.transformers = transformer_order
    new_name = file

  else
    tier_names = Object.keys(transformer_order)
    last_tier = transformer_order[tier_names[tier_names.length - 1]]
    last_renderer = last_tier[last_tier.length - 1]
    output_format = renderers[last_renderer].outputFormat
    new_name = file.replace(input_format, output_format).replace(output_dir, '')

  files[file] = merge files[file],
    is_rendered: false
    new_path: path.join(output_dir, new_name)
    input_format: input_format
    output_format: output_format

make_file_list = ->
  debug 'making file list'
  promises = []
  for file in all_files
    promises.push make_file_data_for(file)

  return Promise.all(promises)

bs_options = merge({
  server: output_dir
}, config.server)

bs.init(bs_options)

rm_dir output_dir

unless fs.existsSync(output_dir)
  fs.mkdir(output_dir)

render = (filename, contents, renderer_names, settings={}) ->
  new Promise (resolve, reject) =>
    file_data = matter(contents)

    contents = file_data.content
    frontmatter = file_data.data

    if renderer_names is 'copy'
      resolve(contents)

    default_transformers_config =
      stylus:
        paths: [
          input_dir
        ]

    renderer_name = renderer_names[0]

    debug "#{filename}: rendering with #{renderer_name}"
    renderer = renderers[renderer_name]
    renderer_config = transformers[renderer_name]

    output_format = renderer.outputFormat

    renderer_config = merge(settings, renderer_config, frontmatter)

    renderer.renderAsync(contents, renderer_config)
      .then (rendered_contents) =>
        debug "#{filename}: finished rendering with #{renderer_name}"
        rendered_contents = rendered_contents.body
        renderers_left = renderer_names[1..]
        if renderers_left.length is 0 or renderers_left is undefined
          resolve(rendered_contents)
        else
          render(filename, rendered_contents, renderers_left)
            .then (final_contents) =>
              resolve(final_contents)
            .catch (err) =>
              reject log 'error', renderer_names[0], '\n' + err
              # throw log 'error', renderer_names[0], '\n' + err
      .catch (err) =>
        reject log 'error', '\n' + err

render_tier = (file, text) ->
  console.log "render_tier('#{file}')"

  new Promise (resolve, reject) =>

    file_data = files[file]

    tier = 'syntax'

    "render('#{file}', '#{text}', '#{file_data.transformers[tier]}', opts)"
    render(file, text, file_data.transformers[tier],
      filename: path.join(input_dir, file), basedir: output_dir)
      .then (rendered_contents) =>
        write_file(file_data.new_path, rendered_contents)
        resolve()
      .catch (err) ->
        reject err

render_file_tier = (file) ->
  console.log "render_file_tier('#{file}')"

  new Promise (resolve, reject) =>

    file_data = files[file]

    if file_data.is_rendered
      resolve(file_data.new_path)

    console.log JSON.stringify file_data.transformers, null, 2
    # list_of_renderers = file_data.transformers.join(' => ')
    # debug ".#{file_data.input_format}
    #   => #{list_of_renderers}
    #   => .#{file_data.output_format}"

    fs.readFile path.join(input_dir, file), { encoding: 'utf8' }, (err, text) =>

      if err
        reject err

      render_tier(file, text)
        .then =>
          file_data.is_rendered = true
          resolve()
        .catch (err) =>
          reject err

render_all = ->
  new Promise (resolve, reject) ->
    # pipeline_promises = []
    # for pipeline of files
    #   file_promises = []
    #   for file of files
    #     file_promises.push render_file_tier(file)
    #   Promise.all(promises)
    #     .then =>
    #       resolve('hi')
    #     .catch (err) =>
    #       reject err

make_file_list()
  .catch (err) ->
    throw err
  .then ->
    console.log JSON.stringify files, null, 2

    render_all().then ->
      chokidar.watch(input_dir, {}).on 'all', (event, file) ->
        if event is 'change' or event is 'remove' or event is 'add'
          file = file.replace input_dir + '/', ''
          files[file].is_rendered = false
          render_all()
            .then (files_changed) =>
              bs.reload(files_changed)
            .catch (err) =>
              throw err

debug 'script ended'
